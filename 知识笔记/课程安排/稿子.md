
### 代理模式在java中的应用

代理，简单来说。就是把自己一些工作，给交别人。腾出精力去做更多的事情。
代理模式，也就是基于此观念产生。
代理模式理解起来很简单，因为生活中处处是代理。因为一个人的精力有限。比如，做法。我自己不想做，没时间。那我找人来帮我做，我只需要付出一点点的代价即可。刚到一个新城市想租房，去app上找房东发布的租房信息。而平台就代替了我到处跑去找租房广告的事情。

那么代理模式在软件开发上是怎么体现的。
最开始，也是最朴素的用法。就是参数校验，以及错误反馈。
假设你有一个类，里面的许多方法都需要参数检验。比如登录这个方法。你拿到账号密码。你得验证账号的格式，账号的长度，账号是否和特殊账号冲突。账号在数据库中存在吗？
然后密码也是验证，检查。还有你还得反馈给调用者各种错误信息，比如账号格式啊，密码错误啊。什么什么的。想想就很麻烦。如果返回的提示要改，或者参数校验规则也要改。岂不是的很麻烦。
所以自然而然的抽取方法，让另一个方法来帮我做这件事。检验啊，反馈。
而我登录方法就只需要负责登录这个功能，进行相应的跳转或者函数方法的调用。

那么当一个类有许多方法都需要这样的代理方法。我们就可以抽取出一个类专门干这样的事情。这样以后有相同的类似参数检验反馈的功能就可以调用这个新类中的方法来完成，而我原来的类就可以保持不变。除非登录的逻辑变了，不然基本的检验变化我都不用管了。

那么在java中使用代理设计模式，从两个类的设计上，就是尽量让外界只能去交互代理类，不应该直接和我原始类接触。这样就会有强制代理这个说法。原始类，只能有代理对象提供，别人直接实例化的类无法使用。这样能保证原始类的实例方法在执行前能得到保证。

其实工厂本身也是一种代理的思想，自己不想管建造的过程，就想买手机肯定是想直接拿到一个整机，除非是那种爱好者，不然不会有人去买一堆零件来组装。

那么java本身提供了jdk动态代理。jdk动态代理的理念很简单，给他一组接口，他帮我产生一个实现这组接口的匿名实现类。通过这个实现类产生的实例，在调用方法的时候都会变成调用invoke方法。这个情况可以说是控制，也可以说是拦截。总之说法很多，意思一样。你拦截了方法的调用你可以什么都不干，就返回一个null。或者做别的类似参数检验啊，消息反馈啊什么的。

理念很简单，但是作用却非常广泛。这一看，既然能用定义接口之后动态代理能帮我产生一个实现类，而且我还能操作这个实现类执行的动作。那岂不是。如果有一些接口的实现类都大致一样，我用这个动态代理就能帮我省去很多共同的方法。少写不少实现类呢。那么mybatis持久层的框架就出来了。写用dao这样的设计，虽然和业务层解耦了，但是我要写很多相同的实现类。假设不用动态代理，自己通过反射写一个反射的代理。也还是很麻烦。这时候就可以考虑jdk动态代理。来帮我做这个事情。

那么这就是代理在java开发中的应用了，普通的代理你可以做参数校验，或者资源归还，资源申请。动态代理可以帮你省去写很多重复的实现类。因为动态代理想干活必须有接口，所以他还不能完全替代上面那一种代理的方式。如果你想动态代理所有东西。那么只能去学习jvm的知识和编译相关的知识，在编译之后做事情。也就是cglib。