## 多版本并发控制
> 作为读写并发的解决方案之一。一般用于RDBMS中应用于**提交读和重复读**的隔离级别。

> 锁可以把一切并发问题解决。但是速度太慢。

> 读写并发的时候每个事务一个副本不现实。

### 读数据
- 当前读
  
```sql
    #对查询结果上行排他锁，事务结束（提交或回滚 锁释放）
    select * from tableName where 条件 for update
```
- 快照读，MVCC处理读写并发，读指的是快照读

### 表中的隐藏列
1. 行id（DB_ROW_ID），一般为主键，如果没有主键，会自动产生主键簇 唯一标识
2. 事务id（DB_TRX_ID），最后一次更新该记录的事务id，系统会自动产生事务id，查看事务：``select * from information_schema.INNODB_TRX``
3. 回滚指针（DB_ROLL_PTR），该指针指向更新前数据，用于回滚

### undo log
- insert undo log，添加数据日志记录，事务提交后，将该日志标识为可以删除状态
- update undo log，修改和删除日志记录，事务提交后，该日志保留构建完整的事务链，关联事务只有完全释放后才会标识为删除状态

### 事务链
> 多事务读写并发过程中，不同事务对数据进行更新会产生一条有规律的业务链条，其中记录数据变化与事务ID信息，以及各个事务之间运行顺序。是并发读数据判定的依据

### ReadView
- 事务在执行快照读的时候会产生ReadView用于捕获以下信息。
- **未提交读**不会产生ReadView。
- **提交读**每次读快照都会产生ReadView
- **重复读**仅在第一次读的时候产生ReadView
1. 当前事务id
2. 活动事务id
3. 最小事务id
4. 下次事务id
  
### 算法规则
1. 当前事务id == 事务链中的最新一条的事务id，该数据可见
2. 当前事务id < 最小事务id，可见

> 本质是一行一个链表，链表中的每个节点就是版本，每个版本是一次更新操作的结果（未提交）。通过遍历链表来选择你合适的节点，也就是所谓的版本。

> mvcc 读视图控制读取方式，链表（头插链表）保存的是更新版本。