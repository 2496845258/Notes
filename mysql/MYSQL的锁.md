### 应用场景
> 一个数据库，会被多个应用程序操作。并发情况很容易发生

> 读读并发，不用防止并发。

> 读写并发，用MVCC。

> 写写并发，必加锁。
### 系统参数
```sql
    #查看死锁情况
    show variables like '%lock%';
```
- 会话级别设置
- innodb_deadlock_detect  死锁监控默认开启
- innodb_lock_wait_timeout 默认等待50秒

```sql
    #显示当前锁状态（冲突）
    select * from performance_schema.data_locks;

    #锁等待时间（查看有冲突的锁），哪两个事务发生了冲突
    select * from performance_schema.data_lock_waits;
```
- lock_type
  - RECORD 行锁
  - TABLE 表锁
  - 
- lock_mode
  - X Exclusive 排它锁
  - S Share 共享锁
- 事务的结束也伴随着行锁的释放。 
### 锁的分类

- 表现形式
  - **隐式锁**（行锁），会话发起数据更新请求，没有人为加锁的情况下，系统默认为该请求的操作行自动加锁。
  - **显式锁**（行锁，表锁），用户根据当前情况，在数据更新之前，自定义添加相关形式的锁，保证操作的稳定性和数据的安全性。
  
- 粒度范围
  - 行锁
    - **行排它锁**：``select * from tableName for update``为查出来的每一行加行排它锁，这样别的事务无法操作该行。(推荐使用)
    - **共享锁**：``select * from tableName lock in share mode``为查出来的行加入一把共享锁。
  - 表锁
    - **只读锁**（会话共享锁），``lock table tableName read``只允许事务读，不允许所有会话对表中的数据进行修改
    - **写锁**（会话排它锁），``lock table tableName write``别的会话，表读都不能读，不能写。只有加锁的会话才能访问和修改。
    - **解表锁**，``unlock tables``;
    > 表锁不与事务的生命周期相关，**innodb**支持行锁，和表锁。**myisam**只支持表锁。有事务在操作表的时候，不能为该表上表锁。表锁会被begin语句自动解锁

  - **间隙锁**，防止幻读，当前读为范围查询时，系统会对逻辑范围内并不存在的间隙加锁。``某个事务在新的一行插入数据后，有别的事务修改这个在它事务内不可见的数据``。可以锁暂时不存在的主键。``虽然我只有2条数据，但是我能锁定1-4行，这样别的事务不能操作3-4行，虽然不存在``
  - **意向锁**，实现行锁和表锁的共存，提高判断效率。解决有一个行锁的表，不让别人加表锁。``其实就是一个标记效果``。添加行锁的时候就添加一个相同类型的意向表锁（排它或共享）。
  - 页锁，粒度介于行锁和表锁之间，BDB搜索引擎创建表条件下可以创建页锁。
  
### 互斥模式
  - 共享锁，共享锁安全级别更高，所以加了共享锁的事务都无法操作，并且极易发生死锁。
  - 排它锁
|共存关系|行共享锁|行排它锁|意向共享锁|意向共享锁|读锁|写锁|

  
- 处理方案
  - 悲观锁，先加锁，后做事，mysql中的锁全是悲观锁。``操作数据时，假设其他人会跟我争夺资源，操作效率低，成功几率高``
  - 乐观锁，先做事，后加锁，redis里的锁全是乐观锁。``操作数据时，假设其他会不会跟我争夺，发生被锁，撤销之前操作。操作不阻塞，操作效率高，成功机率低``
  
### 死锁现象
- 共享锁和行锁，出现死锁几率更高。
- 行锁相比较表锁出现死锁几率低。

### 锁设计的经验
1. 并不是什么情况都一股脑加锁。具体问题具体分析。能少则少，能小则小
2. 查询大 + 更新少 = myisam设计表，使用表锁
3. 写写并发少 + 读写并发多 = 事务管理 + MVCC
4. 写写并发多
   1. 业务尽可能拆分 减少加锁范围
   2. 操作行数量多，就使用表锁
   3. 尽量避免多次频繁加锁
