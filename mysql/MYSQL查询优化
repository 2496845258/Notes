
## SQL优化

### 索引原理
- 聚集索引(innodb)
- 非聚集索引(myisam)
  
|分类|搜索引擎|文件|说明|
|:---:|:---:|:---:|:---:|
|聚集索引|innodb|*.ibd（索引+数据）|索引和数据物理顺序一致，**表只能有一个聚集索引**，主键，默认96k，给了6页，一个页16k，由于是按树插入，插入的是乱序，数据最后会按主键排序。自增主键，不会频繁更新前面索引，**可以与非聚集索引共存**|
|非聚集索引|myisam|*.MYI索引文件 *.MYD数据文件 *.sid是表结构|索引和数据之间通过DB_ROW_ID关联，查询定位索引后，再通过反表获取结果。一个表可以有**多个**非聚集索引，默认0kb，随着添加而变化|

- 截断表自动增长列会初始化
- B+树，叶子节点是双向链表
- 经验
  1. 设计表推荐使用innodb 表如果没有特别要求，尽量使用自增主键。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
  2. 百万级别的数据查询，mysql 完全可以胜任（默认6个索引页96k），16k可以容纳1170的索引量（16k的索引页可以容纳1000个关键字这样）。百万级别，只要3层
### EXPLAIN 反馈表
``explain select * from tableName;``
- select_type（查询模式，效率递减）
  1. 表查询（直接查询）（表联接也是表查询）：simple
  2. 子查询。简单的子查询会转换为直接查询，primark，subquery
  3. 联合查询。union，union result，
  
- type（搜索方式）直接表达是否在按索引查询（从上到下排序）
  1. const，索引的等值查找
  2. eq_ref，外键引用等值查询
  3. ref，外键引用范围
  4. range，索引范围查找
  5. index，索引遍历
  6. all，线性查找
- extra（补充说明）
  1. Using index，索引有效
  2. Using filesort，文件排序（非索引字段排序）
  3. Using temporary，临时表（分组聚合，子查询，联合查询）
  4. Imp...，查无数据
### 管理索引
```sql
  #添加唯一索引（键）
  create unique index 索引名称 on 表名(列1);
  #添加普通索引
  create index 索引名称 on 表名(列1);
  #联合索引
  create index 索引名称 on 表名(列1，列2，...);

  #移除某个索引
  drop index 索引名称 on 表名;
```
经验
1. 表中记录量比较大，查询业务比较多，可考虑设置索引列
2. **尽量**使用数值型的列，避免使用字符列 （比如数字列tinyint，时间列timestamp）类型越小越好。非用不可就用char类型
3. 一张表中的索引字段控制在5个以内
4. 数据重复率比较高的列不建议使用索引。（比如职位，性别）
5. 索引之间会相互影响

### 索引失效（举例）（索引失效并不一定影响效率）
1. 全表扫描时，出现非索引列。（将非索引列设置索引）
2. 全表扫描时，出现索引互斥。（通过联合索引解决）
3. 条件筛选时使用非索引列筛选。（把筛选列设置为索引列）
4. 或使用or关联。（可以尝试使用union）
5. 条件查询NOT NULL，（索引列为空，那一定失效啊）
6. 非索引列排序，将排序列作为索引
7. 模糊查询，不要包含查询（%开头），可以保留从头匹配业务模式。要么就搞个备份列。这个备份列搞字符串倒序，然后用A%
8. 组合索引，左匹配原则（查询列中得出现非索引字段，很多条件都要这样测）
9. 函数会失效（非索引字段）
10. 字符串缺失引号
### SQL优化
> 慢查询（耗时0.5秒以上的查询）。
1. 可以通过索引的方式进行处理，但并不意味着使用索引就提高查询效率。
2. 一般而已对于数据量较大的时候，索引处理效果会更好。此时可以考虑根据实际需求设置对应的索引列。
3. 追根溯源：还是应该从表的设计上认真分析，合理的控制冗余，在特定情况下允许冗余而提高查询效率（联表查询不应该超过3张）
4. 转换本质：关系型数据库本质对数据的查询需要频繁进行数据的io读写操作，应该对常用的数据可以考虑缓存进行优化。
5. 当数据过于庞大时，则应该转换处理方案，通过分布式思路，对数据进行拆分处理后在进行整合。

实际应用
