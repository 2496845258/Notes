## 事务管理
> 事务是一组操作的集合。
> 并发处理

### 1、应用场景
> 不提供保护的业务会产生业务干扰并发，会导致数据混乱。
 
> 那为什么不直接用同步锁，同步锁消耗太大，同步锁就是排队。排队，增加请求等待的时间，存储大量的请求需要大量的空间。（排队）

> 事务是在关系型数据库中保证业务操作的独立性的一种特有方式。
 事务底层原理为多版本并发控制(MVCC)，运行效率比锁高。
 事务的运用场景仅限于读写并发。

### 2、事务特性（ACID）
- 原子性（atomicity），指事务的不可分割性，一个事务的所有操作要么不间断地**全部被执行，要么一个也没有执行**。
  
- 一致性（consistency），一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
    
- 隔离性（isolation），数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括**读未提交、读提交、可重复读、串行化**。*两个事务对数据可见性的控制*。
  
- 持久性（durability），事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失，**数据持久化的标志为事务提交，持久化本质是"脏数据"写入**，所谓的脏数据是事务过程中产生的临时数据。

### 3、事务控制
查看mysql自动提交事务的状态。（默认自动提交事务）
- select @@autocommit
- show variables like '%autocommit%';

不建议更改（更改了也只是当前会话有效），建议使用声明式事务管理

##### 声明式事务控制
```sql
    begin;       #显式开启事务
    ....         #具体的一系列操作
    commit;      #事务提交
    rollback;    #或事务回滚

    #DDL操作成功会自动提交事务。
    create, alter, drop, truncate。

    #所以事务管理一般针对于DML
    insert, update, delete
```

##### 搜索引擎
- innodb引擎，支持事务管理，也支持锁。（需要频繁更新的表）  
- myisy引擎，DML操作必定自动提交，事务失效。并发处理只能用表锁。（不常修改建议使用）
---

##### 嵌套事务
- mysql中不存在事务嵌套，使用多个begin并不能形成嵌套。而且会自动提交上一次未提交的事务，然后开启新事务。
- 在Oracle中存在事务嵌套

#### 保持点（局部回滚）
- 设置保存点，可以在事务中实现局部回滚效果，但是同一个保存点一旦恢复就消失了
```sql
    begin;

    savepoint xxx1;   #设置保存点xxx1
    ...               #各种操作
    savepoint xxx2;   #设置保存点xxx2
    ...               #各种操作

    rollback to xxx1; #回到保存点xxx1

    commit;           #全部提交
```
### 4、隔离性解析
> 控制一个事务对数据进行更新后，另一个事务对该数据的可见性，处理读写并发。
- 写写并发，只能由锁控制，数据库自己会控制。读读并发，并不存在并发影响。
#### 读写并发

##### 读写并发可能会发生的现象
- 脏读：一个事务读取到另一个事务的脏数据。脏数据是可能回滚的。那本读取到的就是一条在数据库中不存在的数据，非常恐怖。

- 幻读：一个事务读取到另一个事务增加或删除的数据变化。在本事务没有增加或删除数据的情况下，竟然有不存在的位置无法插入，或无法更新
  
- 不可重复读：一个事务读取另一个事务更新前后数据变化。在本事务没有更新数据的情况下，前后select查看的结果却发生变化
  
>区别： 幻读的偏重点是添加和删除数据，多次操作数据得到的记录数不一样。不可重复读的偏重点是修改数据，多次读取数据发现数据的值不一样了

##### 事物隔离级别
| 名称 | 英文 | 安全性 | 效率 | 脏读 | 不可重复读 | 幻读 |
| :---: | :---:| :---: | :---: | :---: | :---: | :---: |
|未提交读|read uncommitted|最低|最高|是|是|是|
|提交读|read committed|一般|还行|否|是|是|
|重复读|repeatable read|还行|一般|否|否|是|
|串行化|serializable|最高|最低|否|否|否|

- mysql中的事物隔离级别为重复读
- 查看隔离级别 show variables like 'transaction_isolation'
- 修改隔离级别（会话级别）set session transaction isolation level 级别名称，哪个会话修改，哪个会话就能变更读写权限
- 串行化，相当于直接就是同步锁。你在修改的时候不提交别人不能看

### 我的理解
1. 事务链，本质是由事务对行进行更新操作形成的链表节点，采用头插法。保证数据的最新版本在提交后能被新开启的事务读取到。
2. 读视图，主要考究的是，活动数组。为什么是活动数组，而不是每个事务存储第一次读到的事务链中的节点的指针。存指针内存也是很少的那为什么不直接存，每行第一次读的在事务链节点呢？因为后面查找会很麻烦。即使内存开销少了，但是查找每个对应节点也是不少的时间开销。
3. 并且我并不知道有哪个事务会更新，所以我就把当前可能会修改的事务就保留下来。而且，每个事务是1对多的关系，当前时刻有且只能有一个事务对同一行进行更新，所以就是1对多的关系。那为什么要说1对多，高效啊，速度快啊，我存活动事务，我就能知道每行的哪些节点是我不能访问的。
4. 存节点指针是遍历，存事务id也是数组也是要遍历，但是事务1对多啊。存得更少，遍历更快。而且如果事务id是按顺序增大产生的话。会更极大的方便查找我能读的节点

